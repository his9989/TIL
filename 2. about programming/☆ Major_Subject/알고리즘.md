### Sort
1) 버블 정렬 : 서로 이웃한 데이터를 하나 씩 비교해서 큰 데이터를 뒤로 보내는 정렬 방식.
  * 최선 시간 복잡도 : n^2
  * 최악 시간 복잡도 : n^2
  * 평균 시간 복잡도 : n^2

2) 선택 정렬 : 전체에서 제일 작은애를 0에 두기 -> 그다음 작은애를 1에 두기 -> ..
  * 최선 시간 복잡도 : n^2
  * 최악 시간 복잡도 : n^2
  * 평균 시간 복잡도 : n^2

3) 삽입 정렬 : 1번째 자료는 두고, 2번째 자료부터 시작. arr[2]와 arr[1]을 정렬 -> arr[3]과 {arr[1], arr[2]}를 정렬 -> ...
  * 최선 시간 복잡도 : n
  * 최악 시간 복잡도 : n^2
  * 평균 시간 복잡도 : n^2

4) 빠른 정렬 : 피봇을 기준으로 왼쪽에 피봇보다 작은것, 오른쪽에 피봇보다 큰것을 둔다. 각 부분에 대해 새로운 피봇을 두고 똑같이 정렬한다.
  * 최선 시간 복잡도 : nlog2n
  * 최악 시간 복잡도 : n^2
  * 평균 시간 복잡도 : nlog2n

5) 힙 정렬 : 완전 이진 트리의 일종. 우선순위 큐를 위해 만들어진 자료구조.
  * 과정1. 정렬해야할 n개의 요소들로 최대 힙(완전 이진 트리)을 만든다. 내림차순은 최대힙(루트가 최댓값), 오름차순은 최소힙(루트가 최솟값) 구성
  * 과정2. 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장한다.
  * 과정3. 최댓값부터 삭제되므로, 값이 감소되는 순서로 정렬된다.
  * 최선 시간 복잡도 : nlog2n
  * 최악 시간 복잡도 : nlog2n
  * 평균 시간 복잡도 : nlog2n

6) 병합 정렬 : 문제를 작은 2개의 문제로 분리하고 각각 해결해서 모은 다음 원래의 문제를 해결하는 전략
  * 과정1. 정렬되지 않은 리스트를 절반으로 자른다.
  * 과정2. 각 부분 리스트를 재귀적으로 합병 정렬하여 정렬한다.
  * 과정3. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.
  * 최선 시간 복잡도 : nlog2n
  * 최악 시간 복잡도 : nlog2n
  * 평균 시간 복잡도 : nlog2n

================================================

### Heap : 우선순위큐에서 사용된다.
1) 최대 힙 : 루트가 최댓값인 완전 이진 트리.
2) 최소 힙 : 루트가 최솟값인 완전 이진 트리.
3) 힙 삽입 : 힙의 마지막 노드 다음 위치에 삽입한 노드를 넣는다. 재정렬한다.
4) 힙 삭제 - 최대힙 기준 : 힙의 마지막 노드를 삭제한 노드로 옮긴다. 재정렬한다.

================================================

### Search
1) 순차 탐색 : 그냥 하나씩 찾는 것
  * 최선 시간 복잡도 : 1
  * 최악 시간 복잡도 : n
  * 평균 시간 복잡도 : (n+1)/2

2) 이진 탐색 : 반씩 나눠서 찾는 것
  * 최선 시간 복잡도 : log2n
  * 최악 시간 복잡도 : log2n
  * 평균 시간 복잡도 : log2n

3) 너비 우선 탐색

4) 깊이 우선 탐색

================================================
<code>

		a
	b		c

</code>

전위탐색(prefix) : a -> b -> c

중위탐색(infix) : b -> a -> c

후위탐색(postfix) : b -> c -> a















