### Sort
1) 버블 정렬 : 서로 이웃한 데이터를 하나 씩 비교해서 큰 데이터를 뒤로 보내는 정렬 방식.
  * 최선 시간 복잡도 : n^2
  * 최악 시간 복잡도 : n^2
  * 평균 시간 복잡도 : n^2

2) 선택 정렬 : 전체에서 제일 작은애를 0에 두기 -> 그다음 작은애를 1에 두기 -> ..
  * 최선 시간 복잡도 : n^2
  * 최악 시간 복잡도 : n^2
  * 평균 시간 복잡도 : n^2

3) 삽입 정렬 : 1번째 자료는 두고, 2번째 자료부터 시작. arr[2]와 arr[1]을 정렬 -> arr[3]과 {arr[1], arr[2]}를 정렬 -> ...
  * 최선 시간 복잡도 : n
  * 최악 시간 복잡도 : n^2
  * 평균 시간 복잡도 : n^2

4) 빠른 정렬 : 피봇을 기준으로 왼쪽에 피봇보다 작은것, 오른쪽에 피봇보다 큰것을 둔다. 각 부분에 대해 새로운 피봇을 두고 똑같이 정렬한다.
  * 최선 시간 복잡도 : nlog2n
  * 최악 시간 복잡도 : n^2
  * 평균 시간 복잡도 : nlog2n

5) 힙 정렬 : 완전 이진 트리의 일종. 우선순위 큐를 위해 만들어진 자료구조.
  * 과정1. 정렬해야할 n개의 요소들로 최대 힙(완전 이진 트리)을 만든다. 내림차순은 최대힙(루트가 최댓값), 오름차순은 최소힙(루트가 최솟값) 구성
  * 과정2. 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장한다.
  * 과정3. 최댓값부터 삭제되므로, 값이 감소되는 순서로 정렬된다.
  * 최선 시간 복잡도 : nlog2n
  * 최악 시간 복잡도 : nlog2n
  * 평균 시간 복잡도 : nlog2n

6) 병합 정렬 : 문제를 작은 2개의 문제로 분리하고 각각 해결해서 모은 다음 원래의 문제를 해결하는 전략
  * 과정1. 정렬되지 않은 리스트를 절반으로 자른다.
  * 과정2. 각 부분 리스트를 재귀적으로 합병 정렬하여 정렬한다.
  * 과정3. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.
  * 최선 시간 복잡도 : nlog2n
  * 최악 시간 복잡도 : nlog2n
  * 평균 시간 복잡도 : nlog2n

================================================

### Heap : 우선순위큐에서 사용된다.
1) 최대 힙 : 루트가 최댓값인 완전 이진 트리.
2) 최소 힙 : 루트가 최솟값인 완전 이진 트리.
3) 힙 삽입 : 힙의 마지막 노드 다음 위치에 삽입한 노드를 넣는다. 재정렬한다.
4) 힙 삭제 - 최대힙 기준 : 힙의 마지막 노드를 삭제한 노드로 옮긴다. 재정렬한다.

================================================

### Search
1) 순차 탐색 : 그냥 하나씩 찾는 것
  * 최선 시간 복잡도 : 1
  * 최악 시간 복잡도 : n
  * 평균 시간 복잡도 : (n+1)/2

2) 이진 탐색 : 반씩 나눠서 찾는 것
  * 최선 시간 복잡도 : log2n
  * 최악 시간 복잡도 : log2n
  * 평균 시간 복잡도 : log2n

3) 너비 우선 탐색

4) 깊이 우선 탐색

================================================
### 전위, 중위, 후위 탐색기법
prefix(전위) : 루트->L->R
infix(중위) : L->루트->R ( = 일반적인 수식 해석 방법)
postfix(후위) : L->R->루트

### 자료구조
https://m.blog.naver.com/PostView.nhn?blogId=powhy123&logNo=221009290191&proxyReferer=https%3A%2F%2Fwww.google.com%2F

- 자료구조
	+ 힙 : 우선순위큐에서 사용된다. 당연히 선입선출. 최대힙, 최소힙으로 나뉜다. 루트가 최대인지 최소인지로 구분. 힙 삽입은 마지막 노드의 다음 위치에 노드 삽입 후 재정렬. 힙 삭제는 힙의 마지막 노드를 삭제한 노드 위치로 옮기고 재정렬한다.
	+ 스택, vector : 선입후출
	+ Deque : 큐의 앞 뒤에서 삽입 삭제가 가능한 큐. 원형큐를 상속하여 구현 가능
	+ 큐 : 선입선출. front와 rear가 있다. 배열처럼 보는 것 보단 원형으로 보는게 좋다. 공백 상태는 front == rear, 포화 상태는 front % M == (rear + 1 ) & M. 즉, 하나의 공간은 항상 비워져있다.

- 큐 명령어
Java : 삽입(enqueue), 삭제(dequeue)
C++ : 삽입(push), 삭제(pop)
Python : 삽입(insert), 삭제(delete)

